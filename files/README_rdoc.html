<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>README.rdoc</title>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
            <div class='name'>README.rdoc</div>
            <div class='paths'>
              README.rdoc
            </div>
            <div class='last-update'>
              Last Update:
              <span class='datetime'>2011-08-03 22:52:02 -0400</span>
            </div>
          </div>
          <div id='content'>
            <div id='text'>
              <div id='description'>
                <h1><a href="../classes/LiveAST.html">LiveAST</a></h1>
                <h2>Summary</h2>
                <p>
                Live abstract syntax trees of methods and procs.
                </p>
                <h2>Synopsis</h2>
                <pre>require 'live_ast'&#x000A;&#x000A;class Greet&#x000A;  def default&#x000A;    &quot;hello&quot;&#x000A;  end&#x000A;end&#x000A;&#x000A;#### ASTs of methods&#x000A;&#x000A;p Greet.instance_method(:default).to_ast&#x000A;# =&gt; s(:defn, :default, s(:args), s(:scope, s(:block, s(:str, &quot;hello&quot;))))&#x000A;&#x000A;#### ASTs of lambdas, procs, blocks&#x000A;&#x000A;f = lambda { &quot;foo&quot; }&#x000A;p f.to_ast&#x000A;# =&gt; s(:iter, s(:call, nil, :lambda, s(:arglist)), nil, s(:str, &quot;foo&quot;))&#x000A;&#x000A;def query(&amp;block)&#x000A;  p block.to_ast&#x000A;  # =&gt; s(:iter, s(:call, nil, :query, s(:arglist)), nil, s(:str, &quot;bar&quot;))&#x000A;end&#x000A;&#x000A;query do&#x000A;  &quot;bar&quot;&#x000A;end&#x000A;&#x000A;#### ASTs from dynamic code -- pure ruby version&#x000A;&#x000A;u = ast_eval &quot;lambda { 'dynamic3' }&quot;, binding&#x000A;p u.to_ast&#x000A;# =&gt; s(:iter, s(:call, nil, :lambda, s(:arglist)), nil, s(:str, &quot;dynamic3&quot;))&#x000A;&#x000A;ast_eval &quot;def v ; 'dynamic4' ; end&quot;, binding&#x000A;p method(:v).to_ast&#x000A;# =&gt; s(:defn, :v, s(:args), s(:scope, s(:block, s(:str, &quot;dynamic4&quot;))))&#x000A;&#x000A;#### ASTs from dynamic code -- fully integrated version&#x000A;#### The code below here needs &quot;gem install boc&quot;&#x000A;&#x000A;require 'live_ast/full'&#x000A;&#x000A;f = eval &quot;lambda { 'dynamic1' }&quot;&#x000A;p f.to_ast&#x000A;# =&gt; s(:iter, s(:call, nil, :lambda, s(:arglist)), nil, s(:str, &quot;dynamic1&quot;))&#x000A;&#x000A;eval &quot;def g ; 'dynamic2' ; end&quot;&#x000A;p method(:g).to_ast&#x000A;# =&gt; s(:defn, :g, s(:args), s(:scope, s(:block, s(:str, &quot;dynamic2&quot;))))&#x000A;</pre>
                <h2>Install</h2>
                <pre>% gem install live_ast</pre>
                <p>
                Or from inside an unpacked .tgz download, <tt>rake install</tt> / <tt>rake
                uninstall</tt>.
                </p>
                <h2>Description</h2>
                <p>
                <a href="../classes/LiveAST.html">LiveAST</a> enables a program to find the
                ASTs of objects created by dynamically generated code. It may be used in a
                strictly noninvasive manner, where no standard classes or methods are
                modified, or it may be transparently integrated into Ruby. The default
                setting is in between.
                </p>
                <p>
                RubyParser is the default parsing engine. To replace it with Ripper,
                <tt>gem install live_ast_ripper</tt> and then <tt>require
                'live_ast_ripper'</tt>. A simple plug-in interface allows <a
                href="../classes/LiveAST.html">LiveAST</a> to work with any parser.
                </p>
                <p>
                The advantage of RubyParser is that it gives the traditional ParseTree
                sexps used by tools such as <tt>ruby2ruby</tt>. The disadvantage is that
                the newer Ruby 1.9 syntax is not supported. However the 1.8 syntax
                restriction only applies to files from which ASTs are actually requested.
                All other files may use 1.9 syntax.
                </p>
                <p>
                <a href="../classes/LiveAST.html">LiveAST</a> is thread-safe.
                </p>
                <p>
                Ruby 1.9.2 or higher is required.
                </p>
                <h2>Links</h2>
                <ul>
                <li><p>
                Home: <a
                href="http://quix.github.com/live_ast">quix.github.com/live_ast</a>
                </p>
                </li>
                <li><p>
                Feature Requests, Bug Reports: <a
                href="http://github.com/quix/live_ast/issues">github.com/quix/live_ast/issues</a>
                </p>
                </li>
                <li><p>
                Manual Download: <a
                href="http://github.com/quix/live_ast/archives/master">github.com/quix/live_ast/archives/master</a>
                </p>
                </li>
                <li><p>
                Repository: <a
                href="http://github.com/quix/live_ast">github.com/quix/live_ast</a>
                </p>
                </li>
                </ul>
                <h2><tt>to_ruby</tt></h2>
                <p>
                When the default parser is active,
                </p>
                <pre>require 'live_ast/to_ruby'</pre>
                <p>
                will define the <tt>to_ruby</tt> method for the <tt>Method</tt>,
                <tt>UnboundMethod</tt>, and <tt>Proc</tt> classes. These methods are
                one-liners which pass the extracted ASTs to <tt>ruby2ruby</tt>.
                </p>
                <pre>require 'live_ast/to_ruby'&#x000A;&#x000A;p lambda { |x, y| x + y }.to_ruby # =&gt; &quot;lambda { |x, y| (x + y) }&quot;&#x000A;&#x000A;class A&#x000A;  def f&#x000A;    &quot;A#f&quot;&#x000A;  end&#x000A;end&#x000A;&#x000A;p A.instance_method(:f).to_ruby # =&gt; &quot;def f\n  \&quot;A#f\&quot;\nend&quot;</pre>
                <p>
                In general, <tt>to_ruby</tt> will hook into the unparser provided by the
                parser plug-in, if one is found.
                </p>
                <h2>Pure Ruby and <tt>ast_eval</tt></h2>
                <p>
                An essential feature of <tt>require 'live_ast'</tt> is that it is
                implemented in pure ruby. However since pure ruby is not powerful enough to
                replace <tt>eval</tt>, in this case <tt>ast_eval</tt> must be used instead
                of <tt>eval</tt> for AST-accessible objects. <tt>ast_eval</tt> has the same
                semantics as <tt>eval</tt> except that the binding argument is required.
                </p>
                <pre>require 'live_ast'&#x000A;&#x000A;u = ast_eval &quot;lambda { 'dynamic3' }&quot;, binding&#x000A;p u.to_ast&#x000A;# =&gt; s(:iter, s(:call, nil, :lambda, s(:arglist)), nil, s(:str, &quot;dynamic3&quot;))&#x000A;</pre>
                <h2>Full Integration</h2>
                <p>
                In order for <a href="../classes/LiveAST.html">LiveAST</a> to be
                transparent to the user, <tt>eval</tt> must be replaced. This is
                accomplished with the help of the <tt>boc</tt> gem (<a
                href="http://quix.github.com/boc">quix.github.com/boc</a>).
                </p>
                <p>
                To replace <tt>eval</tt>,
                </p>
                <pre>% gem install boc</pre>
                <p>
                and then
                </p>
                <pre>require 'live_ast/full'</pre>
                <p>
                The new AST-electrified <tt>eval</tt>, <tt>instance_eval</tt>,
                <tt>module_eval</tt>, <tt>class_eval</tt>, and <tt>Binding#eval</tt> all
                pass RubySpec (<a target="_top" href="http://rubyspec.org">rubyspec.org</a>) with the
                minor exception of backtraces sometimes not matching that of the original
                <tt>eval</tt> (see the &#8220;Backtraces&#8221; section below for details).
                </p>
                <pre>require 'live_ast/full'&#x000A;&#x000A;f = eval &quot;lambda { 'dynamic1' }&quot;&#x000A;p f.to_ast&#x000A;# =&gt; s(:iter, s(:call, nil, :lambda, s(:arglist)), nil, s(:str, &quot;dynamic1&quot;))</pre>
                <p>
                Since <a href="../classes/LiveAST.html">LiveAST</a> itself is pure ruby,
                any new platforms supported by <tt>boc</tt> should work with
                <tt>live_ast/full</tt>.
                </p>
                <h2>Limitations</h2>
                <p>
                A method or block definition must not share a line with other methods or
                blocks in order for its AST to be accessible.
                </p>
                <pre>require 'live_ast'&#x000A;&#x000A;class A&#x000A;  def f ; end ; def g ; end&#x000A;end&#x000A;A.instance_method(:f).to_ast # =&gt; raises LiveAST::MultipleDefinitionsOnSameLineError&#x000A;&#x000A;a = lambda { } ; b = lambda { }&#x000A;a.to_ast # =&gt; raises LiveAST::MultipleDefinitionsOnSameLineError&#x000A;</pre>
                <p>
                Code given to the <tt>-e</tt> command-line switch is not AST-accessible.
                </p>
                <p>
                Evaled code appearing before <tt>require 'live_ast/full'</tt> is not
                AST-accessible.
                </p>
                <p>
                In some circumstances <tt>ast_eval</tt> and the replaced <tt>eval</tt> will
                not give the same backtrace as the original <tt>eval</tt> (next section).
                </p>
                <hr style="height: 2px"></hr><h2><em>Technical Issues</em></h2>
                <p>
                You can probably skip these next sections. Goodbye.
                </p>
                <hr style="height: 2px"></hr><h2>Backtraces</h2>
                <p>
                <tt>ast_eval</tt> is meant to be compatible with <tt>eval</tt>. For
                instance the first line of <tt>ast_eval</tt>&#8217;s backtrace should be
                identical to that of <tt>eval</tt>:
                </p>
                <pre>require 'live_ast'&#x000A;&#x000A;ast_eval %{ raise &quot;boom&quot; }, binding&#x000A;# =&gt; test.rb:3:in `&lt;main&gt;': boom (RuntimeError)</pre>
                <p>
                Let&#8217;s make a slight change,
                </p>
                <pre>require 'live_ast'&#x000A;&#x000A;f = ast_eval %{ lambda { raise &quot;boom&quot; } }, binding&#x000A;f.call&#x000A;# =&gt; test.rb|ast@a:3:in `block in &lt;main&gt;': boom (RuntimeError)</pre>
                <p>
                What the heck is &#8216;<tt>|ast@a</tt>&#8217; doing there? LiveAST&#8217;s
                implementation has just been exposed: each source input is assigned a
                unique key which enables a Ruby object to find its own definition.
                </p>
                <p>
                In the first case above, <tt>ast_eval</tt> has removed the key from the
                exception backtrace. But in the second case there is no opportunity to
                remove it since <tt>ast_eval</tt> has already returned.
                </p>
                <p>
                If you find this to be problem&#8212;for example if you cannot add a filter
                for the jump-to-location feature in your editor&#8212;then <tt>raise</tt>
                may be redefined to strip these tokens,
                </p>
                <pre>require 'live_ast'&#x000A;require 'live_ast/replace_raise'&#x000A;&#x000A;f = ast_eval %{ lambda { raise &quot;boom&quot; } }, binding&#x000A;f.call&#x000A;# =&gt; test.rb:4:in `block in &lt;main&gt;': boom (RuntimeError)</pre>
                <p>
                However this only applies to a <tt>raise</tt> call originating from Ruby
                code. An exception from within a native method will likely still contain
                the token in its backtrace (e.g., in MRI the exception raised by
                <tt>1/0</tt> comes from C).
                </p>
                <h2>Replacing the Parser</h2>
                <p>
                Despite its name, <a href="../classes/LiveAST.html">LiveAST</a> knows
                nothing about ASTs. It merely reports what it finds in the line-to-AST hash
                returned by the parser&#8217;s <tt>parse</tt> method. Replacing the parser
                class is therefore easy: the only specification is that the <tt>parse</tt>
                instance method return such a hash.
                </p>
                <p>
                To override the default parser with your own,
                </p>
                <pre>LiveAST.parser = YourParser</pre>
                <p>
                To test it, provide some examples of what the ASTs look like in
                <tt>YourParser::Test</tt>. See the <tt>live_ast_ruby_parser</tt> gem for
                reference.
                </p>
                <h2>Noninvasive Mode</h2>
                <p>
                For safety purposes, <tt>require 'live_ast'</tt> performs the invasive act
                of redefining <tt>load</tt> (but not <tt>require</tt>); otherwise bad
                things can happen to the unwary. The addition of <tt>to_ast</tt> to a few
                standard Ruby classes is also a meddlesome move.
                </p>
                <p>
                To avoid these modifications,
                </p>
                <pre>require 'live_ast/base'</pre>
                <p>
                will provide the essentials of <a
                href="../classes/LiveAST.html">LiveAST</a> but will not touch core classes
                or methods.
                </p>
                <p>
                To select features individually,
                </p>
                <pre>require 'live_ast/to_ast'       # define to_ast for Method, UnboundMethod, Proc&#x000A;require 'live_ast/to_ruby'      # define to_ruby for Method, UnboundMethod, Proc&#x000A;require 'live_ast/ast_eval'     # define Kernel#ast_eval&#x000A;require 'live_ast/ast_load'     # define Kernel#ast_load (mentioned below)&#x000A;require 'live_ast/replace_load' # redefine Kernel#load</pre>
                <h2>Noninvasive Interface</h2>
                <p>
                The following alternative interface is available.
                </p>
                <pre>require 'live_ast/base'&#x000A;&#x000A;class A&#x000A;  def f&#x000A;    &quot;A#f&quot;&#x000A;  end&#x000A;end&#x000A;&#x000A;p LiveAST.ast(A.instance_method(:f))&#x000A;# =&gt; s(:defn, :f, s(:args), s(:scope, s(:block, s(:str, &quot;A#f&quot;))))&#x000A;&#x000A;p LiveAST.ast(lambda { })&#x000A;# =&gt; s(:iter, s(:call, nil, :lambda, s(:arglist)), nil)&#x000A;&#x000A;f = LiveAST.eval(&quot;lambda { }&quot;, binding)&#x000A;&#x000A;p LiveAST.ast(f) &#x000A;# =&gt; s(:iter, s(:call, nil, :lambda, s(:arglist)), nil)&#x000A;&#x000A;ast_eval  # =&gt; raises NameError</pre>
                <h2>Reloading Files In Noninvasive Mode</h2>
                <p>
                Use <tt>ast_load</tt> or (equivalently) <tt>LiveAST.load</tt> when
                reloading an AST-aware file.
                </p>
                <pre>require 'live_ast/ast_load'&#x000A;require 'live_ast/to_ast'&#x000A;&#x000A;require &quot;foo&quot;&#x000A;Foo.instance_method(:bar).to_ast  # caches AST&#x000A;&#x000A;# ... the bar method is changed in foo.rb ...&#x000A;&#x000A;ast_load &quot;foo.rb&quot;&#x000A;p Foo.instance_method(:bar).to_ast  # =&gt; updated AST</pre>
                <p>
                Note if <tt>load</tt> is called instead of <tt>ast_load</tt> then the last
                line will give the old AST,
                </p>
                <pre>load &quot;foo.rb&quot;                       # oops! forgot to use ast_load&#x000A;p Foo.instance_method(:bar).to_ast  # =&gt; stale AST</pre>
                <p>
                Realize that <tt>foo.rb</tt> may be referenced by an unknown number of
                methods and blocks. If the original <tt>foo.rb</tt> source were dumped in
                favor of the modified <tt>foo.rb</tt>, then an unknown number of those
                references would be invalidated (and some may even point to the wrong AST).
                </p>
                <p>
                This is the reason for the caching that results in the stale AST above. It
                should now be clear why the default behavior of <tt>require 'live_ast'</tt>
                is to redefine <tt>load</tt>: doing so prevents this problem entirely. On
                the other hand if it is fully known where files are being reloaded (if at
                all) then there&#8217;s no need for paranoia; the noninvasive option may be
                the most appropriate.
                </p>
                <h2>The Source/AST Cache</h2>
                <p>
                <tt>ast_eval</tt> and <tt>load</tt> cache all incoming code, while
                <tt>require</tt>d files are cached on a need-to-know basis. When an AST is
                requested, the corresponding source file is parsed and discarded, leaving
                behind method and block ASTs. <tt>to_ast</tt> removes an AST from the cache
                and attaches it to the appropriate object (a <a
                href="../classes/Proc.html">Proc</a> or Module).
                </p>
                <p>
                Ignored, unextracted ASTs will therefore linger in the cache. Since sexps
                are generally small there is little need for concern unless one is
                continually evaling/reloading <em>and</em> failing to extract the sexps.
                Nevertheless it is possible that old ASTs will eventually need to be
                garbage collected. To flush the cache,
                </p>
                <p>
                (1) Check that <tt>to_ast</tt> has been called on all objects whose ASTs
                are desired.
                </p>
                <p>
                (2) Call <tt>LiveAST.flush_cache</tt>.
                </p>
                <p>
                Calling <tt>to_ast</tt> prevents the object&#8217;s AST from being flushed
                (since it grafts the AST onto the object).
                </p>
                <p>
                ASTs of procs and methods whose sources lie in <tt>require</tt>d files will
                never be flushed. However a method redefined via <tt>ast_eval</tt> or
                <tt>load</tt> is susceptible to <tt>flush_cache</tt> even when its original
                definition pointed to a <tt>require</tt>d file.
                </p>
                <h2>About <tt>require</tt></h2>
                <p>
                No measures have been taken to detect manipulations of
                <tt>$LOADED_FEATURES</tt> which would cause <tt>require</tt> to load the
                same file twice. Though <tt>require</tt> <em>could</em> be replaced in
                similar fashion to <tt>load</tt>&#8212;heading off problems arising from
                such &#8220;raw&#8221; reloads&#8212;the overhead would seem inappropriate
                in relation to the rarity of this case.
                </p>
                <p>
                Therefore the working assumption is that <tt>require</tt> will load a file
                only once. Furthermore, if a file has not been reloaded then it is assumed
                that the file is unmodified between the moment it is <tt>require</tt>d and
                the moment the first AST is pulled from it.
                </p>
                <h2>Author</h2>
                <ul>
                <li><p>
                James M. Lawrence < quixoticsycophant@gmail.com >
                </p>
                </li>
                </ul>
                <h2>License</h2>
                <pre>Copyright (c) 2011 James M. Lawrence. All rights reserved.&#x000A;&#x000A;Permission is hereby granted, free of charge, to any person&#x000A;obtaining a copy of this software and associated documentation files&#x000A;(the &quot;Software&quot;), to deal in the Software without restriction,&#x000A;including without limitation the rights to use, copy, modify, merge,&#x000A;publish, distribute, sublicense, and/or sell copies of the Software,&#x000A;and to permit persons to whom the Software is furnished to do so,&#x000A;subject to the following conditions:&#x000A;&#x000A;The above copyright notice and this permission notice shall be&#x000A;included in all copies or substantial portions of the Software.&#x000A;&#x000A;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,&#x000A;EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF&#x000A;MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND&#x000A;NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS&#x000A;BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN&#x000A;ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN&#x000A;CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#x000A;SOFTWARE.</pre>
              </div>
              <div id='context'>
              </div>
            </div>
          </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
